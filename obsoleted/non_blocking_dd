#!/usr/bin/perl -w
#
# non blocking read/write program, used to get around
# the bug of /proc/kmsg read on Ubuntu + Xen platforms
#
# __copy1__
# __copy2__
#
# original author: Lorenzo Canovi (lorenzo@kubiclabs.com)
#
# On Ubuntu system >= 8.10 we must install a vanilla+xen
# kernel because the xen kernel in the Ubuntu distro is
# broken; always runs fine, apart from a strange effect
# on /proc/kmsg
#
# Debian/Ubuntu uses a "dd bs=1" on this pseudofile to
# copy content and made it available, via a pipefile,
# to the unprivileged klogd daemon
#
# But with Xen kernel, you can read the /proc/kmsg,
# via dd or cat, only once, and then the process will
# hung forever
#
# I wrote this simple non-blocking read/write program to
# bypass the problem, it can be used instead of "dd" in the
# system /etc/init.d/klogd script
#
if (scalar @ARGV != 2) {
	die( "
usage: $0 input output
\n");
}

my $IN	= "<$ARGV[0]";
my $OUT = ">$ARGV[1]";

open( OUT, $OUT )	or die "can't write $OUT: $!\n";
open( IN, $IN )		or die "can't read $IN: $!\n";

my $rin		= '';
my $ready	= 0;
my $tread	= 0;
my $cread	= 0;
my $cwrite	= 0;

##printf( "IN fileno=%d\n", fileno(IN) );

$| = 1;

my $cnt = 0;

while (1) {
	###exit( 0 )	if (++$cnt > 10000);
	vec( $rin, fileno(IN), 1 ) = 1;
	$ready	= select( $rin, undef, undef, 1 );
	if ($ready != 0) {
		$cread = sysread( IN, $buf, $ready );
		if (!$cread) {
			printf( "\nread 0 " );
			sleep( 1.0 );
			next;
		}
		$cwrite = syswrite( OUT, $buf, $ready );
		if ($cread != $cwrite) {
			die "read=$cread, write=$cwrite!\n";
		}
		$tread += $cread;
		printf( "%d\r", $tread );
		next;
	}
	##printf( "." );
	sleep( 1.0 );
}
